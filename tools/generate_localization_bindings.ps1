Param(
  [Parameter(Mandatory=$true)][string]$CsvPath,
  [Parameter(Mandatory=$true)][string]$OutPath
)

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

function Sanitize-Name([string]$raw, [hashtable]$existing) {
  $sanitized = [Regex]::Replace($raw, '[^0-9A-Za-z_]+', '_')
  $sanitized = [Regex]::Replace($sanitized, '_+', '_').Trim('_')

  if ($sanitized.Length -gt 0 -and [Char]::IsDigit($sanitized[0])) { $sanitized = "_" + $sanitized }
  if ([string]::IsNullOrEmpty($sanitized)) { $sanitized = "Key" }

  $candidate = $sanitized
  $suffix = 1
  while ($existing.ContainsKey($candidate)) {
    $suffix += 1
    $candidate = "{0}_{1}" -f $sanitized, $suffix
  }
  $existing[$candidate] = $true
  return $candidate
}

try {
  if ([string]::IsNullOrWhiteSpace($CsvPath)) { throw "CsvPath is empty" }
  if ([string]::IsNullOrWhiteSpace($OutPath))  { throw "OutPath is empty" }

  if (-not (Test-Path -LiteralPath $CsvPath)) {
    throw "Input csv not found: $CsvPath"
  }

  $rows = Import-Csv -LiteralPath $CsvPath

  $keys = @()
  foreach ($row in $rows) {
    $name = $row.MethodName
    if ([string]::IsNullOrEmpty($name)) { continue }
    if ($name.StartsWith("_")) { continue }
    $keys += $name
  }
  if ($keys.Count -eq 0) { throw "No keys found in csv: $CsvPath" }

  $lines = New-Object System.Collections.Generic.List[string]
  $lines.Add("#pragma once")
  $lines.Add("// Auto-generated by tools/generate_localization_bindings.ps1. Do not edit by hand.")
  $lines.Add("#include <string>")
  $lines.Add("")
  $lines.Add("struct LocalizationKeysAccessor")
  $lines.Add("{")
  $lines.Add("        const char* Get(const std::string& key) const;")
  $lines.Add("")

  $seen = @{}
  foreach ($original in $keys) {
    $method = Sanitize-Name $original $seen
    $escapedComment = $original.Replace("`r","").Replace("`n","\n")
    $escapedLiteral = $original.Replace("\", "\\").Replace('"', '\"').Replace("`r","").Replace("`n","\n")

    $lines.Add("        // $escapedComment")
    $lines.Add("        inline const char* $method() const { return Get(""$escapedLiteral""); }")
    $lines.Add("")
  }

  if ($lines.Count -gt 0 -and $lines[$lines.Count - 1] -eq "") { $lines.RemoveAt($lines.Count - 1) }
  $lines.Add("};")
  $lines.Add("")

  $outDir = Split-Path -Parent $OutPath
  if (-not [string]::IsNullOrEmpty($outDir)) { New-Item -ItemType Directory -Force -Path $outDir | Out-Null }

  $content = ($lines -join "`n") + "`n"
  Set-Content -LiteralPath $OutPath -Value $content -Encoding UTF8

  exit 0
}
catch {
  Write-Host "[Localization] Failed to regenerate localization bindings."
  Write-Host "[Localization] $($_.Exception.Message)"
  exit 1
}
